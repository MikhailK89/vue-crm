********** 1-2 **********

1.
Устанавливаем Vue CLI
npm install -g @vue/cli

2.
Запускаем менеджер проектов
vue ui

В настройках пресета выбираем
- Babel
- Progressive Web App (PWA) Support
- Router
- Vuex
- CSS Pre-processors
- Linter / Formatter
- Использовать файл

history mode нужен для использования путей через /
Sass/SCSS (with node-sass)

3.
В VS Code необходимо установить расширение Vetur для работы с Vue

4.
Устанавливаем библиотеку MaterializeCSS
npm install materialize-css@next

Подключаем библиотеку внутри App.vue
Знак ~ ведёт к папке node_modules
@import '~materialize-css/dist/css/materialize.min.css';

Импортируем index.css из папки assets
@import 'assets/index.css';
при использовании алиаса @ в пути выдавал ошибку

Подключаем файл js из библиотеки MaterializeCSS внутри main.js
import 'materialize-css/dist/js/materialize.min'

Подключаем иконки в файле public/index.html
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

5.
EditorConfig позволяет поддерживать единый стиль кода проекта
независимо от редактора
Создаём файл .editorconfig
Устанавливаем расширение для редактора EditorConfig for VS Code

6.
Создаём папку src/layouts
В ней хранятся слои (базовые элементы окна для разных страниц)

Создаём страницы внутри папки src/views

Настраиваем роуты в файле src/router/index.js
В роутах можно использовать алиас @ в путях
Добавляем свойство meta, чтобы привязать страницы к нужным слоям
Внутри App.vue мы сможем получить данные из meta свойства

7.
Настраиваем рендеринг внутри App.vue
<component :is="layout"> рендерит слой
<router-view/> рендерит страницу (view) по текущему роуту

:is="layout" относится к методу computed.layout()

Делаем import слоёв (алиасы работают) и регистрируем их в components

********** 3 **********

8.
Выносим элементы слоёв в отдельные компоненты
Внутри папки components/app создаём компоненты Navbar и Sidebar
Данные компоненты необходимо зарегистрировать и прописать в MainLayout
Вставляем компоненты внутрь слоя
<Navbar />
<Sidebar />

9.
В компоненте Sidebar вставляем <router-link> для ссылок
Заменяем элемент <li> на <router-link>

10.
@click.prevent модификатор события (аналогичен preventDefault)
@click.prevent="$emit('click')" передаём пользовательское событие наверх
Пользовательское событие может иметь любое название

Внутри MainLayout слушаем данное событие через v-on:click или @click
В том же файле внутри свойства data создаём состояние isOpen
@click="isOpen = !isOpen" переключаем значение состояния
:class="{full: !isOpen}" добавляем класс "full" если isOpen === false
<Sidebar v-model="isOpen" /> передаём состояние в Sidebar

Внутри Sidebar принимаем состояние через props
Фактически value принимает значение isOpen
:class="{open: value}" показываем Sidebar если isOpen === true

********** 4 **********

11.
Заменяем ссылку внутри <div class="fixed-action-btn"> на <router-link>
Инициализируем элемент Dropdown из MaterializeCSS в Navbar.vue
mounted() это life cycle хук, который вызывается после монтирования dom-дерева
ref="dropdown" это ссылка на элемент (название любое)
this.$refs это обращение к ссылкам
@click.prevent="logout" вызывает метод methods.logout()
this.$router.push('/login?message=logout') редирект на другую страницу
'/login?message=logout' передаём параметр
{{date}} вставляем значение, которое хранится в data
beforeDestroy() это life cycle хук, который вызывается перед размонтированием компонента

src/filters хранит фильтры, которые помогают модифицировать данные
В файле main.js импортируем те или иные фильтры и там же их регистрируем
Vue.filter('date', dateFilter) передаём название и функцию фильтра
{{date | date('datetime')}} применяем фильтр к параметру внутри компонента
Фильтр date становится виден в глобальной области
В него можно передавать дополнительные параметры

********** 5 **********

12.
Валидация формы с помощью плагина Vuelidate

Login.vue
@submit.prevent="submitHandler" вешаем обработчик на форму
type="submit" на элементе <button> позволяет вызвать данное событие

Устанавливаем плагин Vuelidate
npm install --save vuelidate

Внутри main.js импортируем данный плагин
Vue.use(Vuelidate) и регистрируем его
В каждом компоненте появляется новое свойство validations
Названия полей validations соответствуют названиям полей data
Импортируем валидаторы
import {} from 'vuelidate/lib/validators'
v-model.trim="email" привязываем модель из data
trim это модификатор, который удаляет пробелы
$v.email через объект $v мы получаем результат валидации
$v.email.$dirty в поле уже что-то вписывалось
$v.email.required поле должно быть заполнено
$v.email.email поле должно иметь формат email
Запускаем валидацию при нажатии на кнопку (событие submit)
this.$v.$invalid форма находится в состоянии invalid
this.$v.$touch() запускаем валидацию
v-if=""
v-else-if="" показывать тег при выполнении условия
$v.password.minLength соответствует ли пароль заданной длине
$v.password.$params.minLength.min динамически извлекаем ограничение по количеству символов
formData для отправки на сервер

********** 6 **********

13.
Валидация формы Register.vue

agree: {checked: v => v} наш собственный валидатор
Он принимает значение true или false и возвращает значение true или false

Выход из системы обрабатывается с помощью плагина Toast библиотеки MaterializeCSS (всплывающее сообщение)
Оборачиваем данный плагин в наш собственный плагин
Он расположен в src/utils/message.plugin.js
Импортируем и регистрируем его в файле main.js
Vue.use(messagePlugin)
На странице Login.vue вызываем данный плагин в хуке mounted()
Внутри src/utils создаём файл messages.js
В нём хранятся ключи и соответствующие им сообщения
Например, при выходе из системы мы передаём параметр /login?message=logout
logout соответствует сообщению 'Вы вышли из системы'
this.$route.query.message извлекаем параметр logout

********** 7 **********

14.
Сохраняем конфиг Firebase в файле main.js
Устанавливаем Firebase
npm install --save firebase
В файле main.js импортируем модули Firebase
Инициализируем Firebase

firebase.auth().onAuthStateChanged() обработчик события
Срабатывает когда пользователь авторизовался
В самом коллбэке создаётся приложение Vue один раз, так как обработчик может срабатывать

15.
В папке store создаём файл auth.js
Это модуль для Vuex
Импортируем его в файле store/index.js
В поле modules добавляем auth
Модуль auth содержит логику авторизации, регистрации и log-out

store/auth.js
Поле actions содержит методы, которые мы будем диспатчить
login() пользователь пробует авторизоваться в Firebase с помощью email и пароля
Пробуем на странице Login.vue задиспатчить данный метод
Данные операции являются ассинхронными и используют async/await
При ошибке авторизации метод login() пробрасывает ошибку, которую мы перехватываем в Login.vue
Это необходимо, чтобы не допустить редирект на главную страницу после ошибки авторизации

********** 8 **********

store/auth.js
logout() очищает информацию при выходе пользователя
Диспатчим данный экшен в компоненте Navbar.vue
register() регистрация нового пользователя в Firebase

getUid() возвращает id пользователя в Firebase, если он там есть
dispatch('getUid') экшены можно вызывать только через dispatch()

При регистрации заносим в базу данных начальные параметры по пользователю
await firebase.database().ref(`/users/${uid}/info`).set({
  bill: 10000,
  name
})
ref() ведёт к нужной таблице
set() вносит данные в таблицу

Внутри Firebase в разделе Database необходимо создать базу данных
В данном проекте использовался вариант Realtime Database
В правилах необходимо разрешить доступ к базе данных авторизованным пользователям
{
  "rules": {
    ".read": "auth != null",
    ".write": "auth != null"
  }
}

В Register.vue делаем диспатч экшена register()

16.
Создаём шину обработки ошибок

store/index.js
Создаём state error
Поле mutations используется для изменения state
Поле getters используется для доступа к значениям state

В EmptyLayout.vue создаём компьютед свойство error(),
которое меняется при изменении state error
this.$store.getters.error получение геттера внутри лейаута
watch.error() следит за изменением компьютед свойства и принимает на вход его значение
Данная цепочка действий начинается с мутации стейта через вызов setError()

store/auth.js
Внутри login() вызываем метод commit(), который изменяет стейт
commit('setError', e) в setError() передаём объект ошибки при авторизации или регистрации
Код данных ошибок имеет значение 'auth/user-not-found'
Переносим его в utils/messages.js

watch.error() в EmptyLayout.vue фактически выводит сообщение об ошибке

********** 9 **********

17.
store/info.js
В данном модуле создаём состояние info
fetchInfo() получаем из базы данных поле info, которое мы создали следующим образом
await firebase.database().ref(`/users/${uid}/info`).set({
  bill: 10000,
  name
})

Следующая строка извлекает данные из Firebase
const info = (await firebase.database().ref(`/users/${uid}/info`).once('value')).val()

setInfo() изменяет состояние

mutations необходимо вызывать через метод commit

MainLayout.vue
Проверяем, чтобы объект состояния не был пустым
Превращаем объект в массив и смотрим его длину
!Object.keys(this.$store.getters.info).length

Navbar.vue
computed.name() возвращает имя пользователя info.name из состояния

18.
Декомпозируем страницу Home.vue на компоненты HomeBill.vue и HomeCurrency.vue
Создаём компонент Loader.vue
Лоадер возьмём из Preloader MaterializeCSS
Цвет лоадера будем выбирать случайно из массива
В main.js импортируем лоадер
Vue.component('Loader', Loader) регистрируем лоадер глобально

Home.vue
Подключаем лоадер
data хранит модели
Лоадер останавливаем, когда загрузим список валют

Курсы валют мы получим через Fixer API

Создаём файл .env
Он позволяет скрывать переменные, которые содержат ключи, при заливке на гитхаб
Перезапускаем билд проекта, чтобы подхватились данные переменные

Экшен fetchCurrency() создаём в store/index.js (не выносим в отдельный модуль)
fetchCurrency() возвращает курсы валют
Данный экшен использует нативный метод fetch() для обращения к серверу Fixer API
fetch() можно заменить библиотекой Axios для работы с запросами
Используем следующую строку запроса
fetch(`http://data.fixer.io/api/latest?access_key=${key}&symbols=USD,EUR,RUB`)

Внутри Home.vue диспатчим данный экшен
Передаём полученные данные в компоненты
currency.rates содержит непосредственно курсы валют
По умолчанию основная валюта евро

HomeBill.vue
computed.base() меняет основную валюту на рубли
То есть мы приводим bill к евро, а затем переводим в другие валюты относительно курса евро

filters/currency.filter.js задаёт денежный формат счёта
В main.js регистрируем фильтр
Vue.filter('currency', currencyFilter)

Следующие итераторы идентичны
v-for="cur of currencies"
v-for="cur in currencies"

********** 10 **********

19.


начать урок 10
время 00:00:00
запустить проект npm run serve
